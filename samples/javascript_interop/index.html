<!DOCTYPE html>
<html>
<head>
  <title>MRuby + JavaScript Interop Tests</title>
  <link rel="stylesheet" href="css/monokai.css">
  <style>
    table {
      border-collapse: collapse;
      background-color: #272822;
      color: white;
    }
    table, th, td {
      border: 1px solid black;
    }
    thead {
      background-color: grey;
      color: black;
    }
    td {
      padding: 5px;
    }
    test-case {
      display: none;
    }
  </style>

  <script src="js/highlight.pack.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
</head>
<body>

<!-- Creating JavaScript objects from Ruby -->
<test-case>
JS.create_undefined
</test-case>
<test-case>
JS.create_null
</test-case>
<test-case>
JS.create_bool true
</test-case>
<test-case>
JS.create_bool false
</test-case>
<test-case>
JS.create_bool 1
</test-case>
<test-case>
JS.create_bool nil
</test-case>
<test-case>
JS.create_int 3
</test-case>
<test-case>
JS.create_float 4.5
</test-case>
<test-case>
JS.create_string 'Hello, from mruby!'
</test-case>
<test-case>
# Showing the type of JavaScript objects in Ruby

obj = JS.create_object
obj[:myRubyClass] = JS.create_string(obj.class.to_s)
</test-case>

<!-- Checking the type of JavaScript objects from Ruby -->

<test-case>
# `JS.type_of` checks the type of JavaScript objects in Ruby.
# This is similar to JavaScripts "typeof" function, but mirrors the C API.

js_obj = JS.eval "undefined"
JS.create_string JS.type_of(js_obj)
</test-case>
<test-case>
js_obj = JS.eval "null"
JS.create_string JS.type_of(js_obj)
</test-case>
<test-case>
js_obj = JS.eval "true"
JS.create_string JS.type_of(js_obj)
</test-case>
<test-case>
js_obj = JS.eval "false"
JS.create_string JS.type_of(js_obj)
</test-case>
<test-case>
js_obj = JS.eval "1"
JS.create_string JS.type_of(js_obj)
</test-case>
<test-case>
js_obj = JS.eval "1.5"
JS.create_string JS.type_of(js_obj)
</test-case>
<test-case>
js_obj = JS.eval "new Date()"
JS.create_string JS.type_of(js_obj)
</test-case>
<test-case>
js_obj = JS.eval "'test'"
JS.create_string JS.type_of(js_obj)
</test-case>
<test-case>
js_obj = JS.eval "[]"
JS.create_string JS.type_of(js_obj)
</test-case>
<test-case>
js_obj = JS.eval "(function () {})"
JS.create_string JS.type_of(js_obj)
</test-case>
<test-case>
js_obj = JS.eval "{}"
JS.create_string JS.type_of(js_obj)
</test-case>

<!-- Reading primitive values from JavaScript objects in Ruby -->

<test-case>
# Reading values from JavaScript objects into
# their equivalient types in Ruby.
# (Then converting to JavaScript strings to have
#  something to report in the result column)

js_obj = JS.eval "true"
JS.create_string js_obj.bool_value.to_s
</test-case>
<test-case>
js_obj = JS.eval "false"
JS.create_string js_obj.bool_value.to_s
</test-case>
<test-case>
js_obj = JS.eval "1"
JS.create_string js_obj.int_value.to_s
</test-case>
<test-case>
js_obj = JS.eval "1.5"
JS.create_string js_obj.double_value.to_s
</test-case>
<test-case>
js_obj = JS.eval "'test'"
JS.create_string js_obj.string_value
</test-case>

<!-- JS.eval -->

<test-case>
# Using V8.eval to run JavaSCript

JS.eval "'String created by JS.eval'"
</test-case>

<!-- Exposing Ruby functions to JavaScript -->

<test-case>
# User V8.create_function NAME, BLOCK
# to create JavaScript functions from Ruby

# `ls` gives JavaScript access to file system info.
JS.create_function "ls" do |args|
  # TODO: Can't use variable name "result" here without exceptions
  ary = JS.eval("[]")
  Dir.entries('.').each do |e|
    ary.push JS.create_string(e)
  end
  ary
end
</test-case>
<test-case>
# To make your function accessible from JavaScript,
# you have to set it as a property on some other object.

# In this example, we make a global function by assigning
# `strip` as a function property on `window`

# Note that arguments to the function are passed as an array,
# (`args` in this case). This matches the functionality of
# the `arguments` object in JavaScript (everything is optional,
# and it's up to the function to check args and throw errors).

JS.window[:strip] =
  JS.create_function 'strip' do |args|
    JS.create_string args[0].string_value.strip
  end

JS.eval "strip('     Strip my whitespace, please!       ')"
</test-case>

<test-case>
# Any unhandled exceptions in Ruby will be rethrown
# as Error's to the calling JavaScript

JS.create_function 'raise' do |args|
  # Should cause a javascript exception
  raise 'my error'
end
</test-case>

<test-case>
# Call JavaScript functions from Ruby with `apply`
# Signature: `jsFunction.apply(context, args_array)`
# Always provide a block to apply catches any exceptions

JS.eval "function throws() { " +
"   throw 'Exception from `throws()`'; " +
"}"

JS.window[:throws].apply(JS.window, []) do |exc|
  JS.create_string "Block received exception: #{exc}"
end
</test-case>

<test-case>
# Or use the "method_missing" API to call JS
# functions like normal ruby methods. In this case,
# any JavaScript exceptions will be thrown as Ruby
# exceptionss

begin
  JS.window.throws
rescue Exception => exc
  JS.create_string "Ruby caught: #{exc}"
end
</test-case>

<test-case>
# Calling a JavaScript function that throws without a block
# will allow the exception to rise to the calling JavaScript
# NOTE:
#   Your Ruby extension should bail out if a JavaScript
#   call throws and the exception isn't handled. If there
#   is any possibility of an exception, provid a block
#   to `apply` and check for the error.

JS.window[:rbDontCatch] =
JS.create_function "rbDontCatch" do |args|
  JS.window[:throws].apply(JS.window, [])
end
</test-case>

<test-case>
# If you catch a JavaScript exception, you can raise the
# message. If this is uncaught by any rescue blocks, it
# will be thrown again to the calling JavaScript.

JS.create_function "rbRethrow" do |args|
  JS.window[:throws].apply(JS.window, []) do |exc|
    raise exc.message
  end
end
</test-case>

<test-case>
# It is possible to catch a JavaScript exception via the
# block provided to `apply`, and then rethrow it as
# a ruby exception to be handled in a `rescue` block
# (Note: this is the behavior of the method_missing API)

JS.create_function "rbRecatch" do |args|
  begin
    JS.window[:throws].apply(JS.window, []) do |exc|
      raise exc.message
    end
    JS.create_string "FAILED: Should throw over this line"
  rescue Exception => ex
    JS.create_string "Re-threw exception: #{ex.message}"
  end
end
</test-case>

<test-case>
# JS.eval behaves the same way as the method_missing API
# for calling JS functions. Any exceptions are re-raised
# as Ruby exceptions. If you don't catch the and the call
# stack unwinds to a JavaScript frame again, the Exception
# will be re-thrown as a JavaScript exception. And so on...

begin
  JS.eval("throw 'test'")
rescue Exception => exc
  JS.create_string "Caugh exception from eval: #{exc.message}"
end
</test-case>

<div>
  <table id="table">
    <thead>
      <th>Code (Ruby)</th><th>Result (JavaScript)</th>
    </thead>
  </table>
</div>

<script>
  function test(code) {
    var result;
    try {
      result = ruby(code);
    } catch (ex) {
      result = ex.toString();
    }

    // Format code for display (strip whitespace)
    code = code.match(/([^\s][\s\S]*[^\s])/mi)[1]

    if (typeof result == 'function') {
      try {
        result = '// Function result:\n' + JSON.stringify(result());
      } catch (e) {
        if (e.message) {
          result = '// Function threw:\n Error(' + JSON.stringify(e.message) + ')';
        } else {
          result = '// Function threw:\n' + JSON.stringify(e);
        }
      }
    } else {
      result = JSON.stringify(result);
    }

    // Hacky formatting of arrays into a column
    if (result && result.match(/\[/)) {
      result = result.replace(/,/g, ",\n")
    }

    window.table.innerHTML = window.table.innerHTML +
      "<tr><td><pre><code class=\"ruby\">" +
      code +
      "</code></pre></td><td><pre><code class=\"javascript\">" +
      result +
      "</code></pre></td></tr>"
  }

  var tests = Array.prototype.slice.call(document.querySelectorAll("test-case"));
  tests.forEach(function(testCase){
    // \s\S is a hack to match any character (. does not match newlines)
    var code = testCase.textContent;
    test(code);
  });
</script>
</body>
</html>
